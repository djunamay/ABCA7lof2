import pandas as pd
import numpy as np
from tqdm import tqdm
from scipy import io
import scipy as scipy
import collections
import scipy.sparse as sp_sparse
import tables
import time
import numba as nb
from numba_progress import ProgressBar
import os
import ipdb 
import sys

def truncate_array(path, array, counter, Ncells, Ngenes):
    """
    Truncate the contents of a binary file to match the specified array size and update metadata.

    Parameters:
    ----------
    path : str
        The path to the binary file to be truncated.

    array : numpy.ndarray
        The NumPy array whose size will be used for truncation.

    counter : int
        The new size to which the binary file should be truncated.

    Ncells : int
        The number of cells in the original array (metadata).

    Ngenes : int
        The number of genes in the original array (metadata).

    Returns:
    -------
    None

    Notes:
    ------
    This function truncates the contents of a binary file at the specified path to match the size of the
    given NumPy array. It updates metadata within the file to reflect the new array dimensions.

    Example:
    --------
    >>> path = "data.bin"
    >>> array = np.zeros((10, 5), dtype=np.float32)
    >>> counter = 7
    >>> Ncells = 10
    >>> Ngenes = 5
    >>> truncate_array(path, array, counter, Ncells, Ngenes)
    # Truncates "data.bin" to match the size of the 7x5 array and updates metadata.
    """
    temp = open(path, 'r+')
    line = temp.readline()
    temp.close()

    constant = sys.getsizeof(line)

    temp = open(path, 'r+')
    
    if array.ndim==1:
        temp.truncate((array.itemsize*counter)+constant)
        line = temp.readline()
        temp.close()
        newline = line.replace(str(Ncells), str(counter))
    else:
        temp.truncate((array.itemsize*array.shape[1]*counter)+constant)
        line = temp.readline()
        temp.close()
        newline = line.replace(str((Ncells, Ngenes)), str((counter, Ngenes)))
        
    temp = open(path, 'r+')
    temp.writelines(newline)
    temp.close()

    
def get_matrix_from_h5(filename):
    """
    Load a single-cell gene expression matrix from an HDF5 file generated by cellranger count.

    Args:
        filename (str): Path to the HDF5 file containing the gene expression matrix.

    Returns:
        CountMatrix: A named tuple containing the following fields:
            - feature_ref (dict): A dictionary with information about features (genes).
              Contains 'id', 'name', 'feature_type', and additional tag keys.
            - barcodes (numpy.ndarray): An array of cell barcodes (unique identifiers).
            - matrix (scipy.sparse.csc_matrix): A compressed sparse column matrix containing gene counts.

    Notes:
    ------
    This function is adapted from the 10x Genomics cellranger count pipeline. It reads an HDF5 file
    generated by cellranger count and extracts the gene expression matrix along with metadata.

    Example:
    --------
    >>> filename = "gene_expression.h5"
    >>> matrix_data = get_matrix_from_h5(filename)
    >>> matrix_data.feature_ref
    {'id': array([1, 2, 3, ...]),
     'name': array(['GeneA', 'GeneB', 'GeneC', ...]),
     'feature_type': array(['Gene', 'Gene', 'Gene', ...]),
     'additional_tag_key': array(['Tag1', 'Tag2', 'Tag3', ...])}
    >>> matrix_data.barcodes
    array(['barcode1', 'barcode2', 'barcode3', ...])
    >>> matrix_data.matrix
    <scipy.sparse.csc_matrix at 0x123456789>
    """
    CountMatrix = collections.namedtuple('CountMatrix', ['feature_ref', 'barcodes', 'matrix'])
    with tables.open_file(filename, 'r') as f:
        mat_group = f.get_node(f.root, 'matrix')
        barcodes = f.get_node(mat_group, 'barcodes').read()
        data = getattr(mat_group, 'data').read()
        indices = getattr(mat_group, 'indices').read()
        indptr = getattr(mat_group, 'indptr').read()
        shape = getattr(mat_group, 'shape').read()
        matrix = sp_sparse.csc_matrix((data, indices, indptr), shape=shape)
        feature_ref = {}
        feature_group = f.get_node(mat_group, 'features')
        feature_ids = getattr(feature_group, 'id').read()
        feature_names = getattr(feature_group, 'name').read()
        feature_types = getattr(feature_group, 'feature_type').read()
        feature_ref['id'] = feature_ids
        feature_ref['name'] = feature_names
        feature_ref['feature_type'] = feature_types
        tag_keys = getattr(feature_group, '_all_tag_keys').read()
        for key in tag_keys:
            key = key.decode("utf-8")
            feature_ref[key] = getattr(feature_group, key).read()
        return CountMatrix(feature_ref, barcodes, matrix)

def decode(numpy_array):
    """
    Decode byte-encoded strings in a NumPy array and return a new array of Unicode strings.

    Parameters:
    ----------
    numpy_array : numpy.ndarray
        A NumPy array containing byte-encoded strings.

    Returns:
    -------
    numpy.ndarray
        A new NumPy array where byte-encoded strings have been decoded into Unicode strings.

    Notes:
    ------
    This function is useful for converting byte-encoded strings (common in data storage) into Unicode strings
    for easier manipulation and display.

    Example:
    --------
    >>> byte_strings = np.array([b'hello', b'world', b'python'], dtype='S6')
    >>> decoded_strings = decode(byte_strings)
    >>> decoded_strings
    array(['hello', 'world', 'python'], dtype='<U6')
    """
    return np.array([numpy_array[x].decode("utf-8") for x in range(len(numpy_array))])

def write_matrix(ID, counts_path_individual, cell_counts, cell_meta, subset_meta, counter, features_id_out, features_name_out, barcodes_out, Ngenes, i):
    """
    Load and write a gene expression matrix from an HDF5 file to memory-mapped arrays.

    Args:
        ID (str): Identifier for the dataset.
        counts_path_individual (str): Path to the directory containing the HDF5 file.
        cell_counts (numpy.ndarray): Memory-mapped array to store cell counts.
        cell_meta (numpy.ndarray): Memory-mapped array to store cell metadata.
        subset_meta (numpy.ndarray): Memory-mapped array to store subset metadata.
        counter (int): Current position in memory-mapped arrays.
        features_id_out (numpy.ndarray): Memory-mapped array to store feature (gene) IDs.
        features_name_out (numpy.ndarray): Memory-mapped array to store feature (gene) names.
        barcodes_out (numpy.ndarray): Memory-mapped array to store cell barcodes.
        Ngenes (int): Number of genes in each matrix.
        i (int): Index for the current matrix subset.

    Returns:
        int: Updated value of the counter.

    Notes:
    ------
    This function loads a gene expression matrix from an HDF5 file generated by 10x Genomics cellranger
    and writes the matrix data, cell barcodes, and feature information to memory-mapped arrays. It also
    updates the counter for the next matrix subset.

    Example:
    --------
    >>> ID = "sample001"
    >>> counts_path_individual = "/data/samples/"
    >>> cell_counts = np.memmap("cell_counts.npy", dtype='int32', mode='w+', shape=(10000,))
    >>> cell_meta = np.memmap("cell_metadata.npy", dtype='float32', mode='w+', shape=(10000, 3))
    >>> subset_meta = np.memmap("subset_metadata.npy", dtype='int32', mode='w+', shape=(10000,))
    >>> counter = 0
    >>> features_id_out = np.memmap("feature_ids.npy", dtype='U', mode='w+', shape=(30000,))
    >>> features_name_out = np.memmap("feature_names.npy", dtype='U', mode='w+', shape=(30000,))
    >>> barcodes_out = np.memmap("barcodes.npy", dtype='U', mode='w+', shape=(10000,))
    >>> Ngenes = 3000
    >>> i = 0
    >>> counter = write_matrix(ID, counts_path_individual, cell_counts, cell_meta, subset_meta, counter, features_id_out, features_name_out, barcodes_out, Ngenes, i)
    # Loads and writes matrix data and metadata to memory-mapped arrays.
    """
    matrix = get_matrix_from_h5(counts_path_individual + ID + '/outs/filtered_feature_bc_matrix.h5')
    
    mat_array = matrix.matrix.T.toarray()
    temp_ncells = mat_array.shape[0]
    
    barcodes_out[counter:counter+temp_ncells]  = decode(np.array(matrix.barcodes))
    start = i*Ngenes
    stop = start+Ngenes
    features_id_out[start:stop] = decode(np.array(matrix.feature_ref['id']))
    features_name_out[start:stop] = decode(np.array(matrix.feature_ref['name']))
    
    write_counts_to_memmap(mat_array, cell_counts, counter)
    add_metadata(cell_meta, subset_meta, counter, temp_ncells)
    
    counter+=temp_ncells
    
    return counter

@nb.njit(parallel=True)
def write_counts_to_memmap(mat_array, cell_counts, counter):
    """
    Write cell counts from a matrix to a memory-mapped array in parallel.

    Args:
        mat_array (numpy.ndarray): Matrix containing cell counts (genes x cells).
        cell_counts (numpy.ndarray): Memory-mapped array to store cell counts.
        counter (int): Current position in the memory-mapped array.

    Returns:
        None

    Notes:
    ------
    This function writes cell counts from a matrix to a memory-mapped array in parallel using Numba.

    Example:
    --------
    >>> mat_array = np.array([[1, 2, 3], [4, 5, 6]])
    >>> cell_counts = np.memmap("cell_counts.npy", dtype='int32', mode='w+', shape=(6,))
    >>> counter = 0
    >>> write_counts_to_memmap(mat_array, cell_counts, counter)
    # Writes cell counts from the matrix to the memory-mapped array.
    """
    for x in nb.prange(mat_array.shape[0]):
        cell_counts[counter+x] = mat_array[x]

def add_metadata(cell_meta, subset_meta, counter, temp_ncells):
    """
    Add cell metadata to a memory-mapped array for a subset of cells.

    Args:
        cell_meta (numpy.ndarray): Memory-mapped array to store cell metadata.
        subset_meta (int): Metadata value for the current subset of cells.
        counter (int): Current position in the memory-mapped array.
        temp_ncells (int): Number of cells in the current subset.

    Returns:
        None

    Notes:
    ------
    This function adds metadata values to a memory-mapped array for a subset of cells.
    
    Example:
    --------
    >>> cell_meta = np.memmap("cell_metadata.npy", dtype='int32', mode='w+', shape=(10000,))
    >>> subset_meta = 1
    >>> counter = 0
    >>> temp_ncells = 3
    >>> add_metadata(cell_meta, subset_meta, counter, temp_ncells)
    # Adds metadata value '1' to a subset of cells in the memory-mapped array.
    """
    for x in range(temp_ncells):
        cell_meta[counter+x] = subset_meta
        
def get_metadata(meta, Library_ID, barcodes):
    """
    Retrieve metadata for a specific library and associate it with cell barcodes.

    Args:
        meta (pandas.DataFrame): DataFrame containing metadata for different libraries.
        Library_ID (str): Identifier for the library of interest.
        barcodes (numpy.ndarray): Array containing cell barcodes.

    Returns:
        numpy.ndarray: An array where each row represents a cell with associated metadata.

    Notes:
    ------
    This function retrieves metadata for a specific library identified by `Library_ID`
    from a metadata DataFrame and associates it with cell barcodes.

    Example:
    --------
    >>> import pandas as pd
    >>> meta_data = pd.DataFrame({'sample_id': ['SampleA', 'SampleB', 'SampleC'],
    ...                           'metadata_column': [1, 2, 3]})
    >>> Library_ID = 'SampleB'
    >>> barcodes = np.array(['cell1', 'cell2', 'cell3'])
    >>> result = get_metadata(meta_data, Library_ID, barcodes)
    >>> result
    array([['cell1', 'SampleB', 2],
           ['cell2', 'SampleB', 2],
           ['cell3', 'SampleB', 2]], dtype=object)
    """
    subset_meta = np.array(meta[meta['sample_id']==Library_ID])[0]
    subset_meta = np.array([subset_meta,]*len(barcodes))
    subset_meta = np.concatenate((barcodes[:,None], subset_meta), axis = 1)
    
    return subset_meta

def aggregate_fastqs(path_to_outputs, meta_path_individual, counts_path_individual, Ncells=300000, Ngenes=36601):
    """
    Aggregate gene expression matrices and associated metadata from individual samples.

    Args:
        path_to_outputs (str): Path to the directory where aggregated data will be saved.
        meta_path_individual (str): Path to the metadata file for individual samples.
        counts_path_individual (str): Path to the directory containing individual sample count data.
        Ncells (int): Total number of cells in the aggregated dataset.
        Ngenes (int): Total number of genes in the aggregated dataset.

    Returns:
        None

    Notes:
    ------
    This function aggregates gene expression matrices and associated metadata from individual samples.
    It combines data from multiple samples into a single dataset and saves the aggregated data.

    Example:
    --------
    >>> path_to_outputs = "/data/aggregated/"
    >>> meta_path_individual = "/data/meta_individual.csv"
    >>> counts_path_individual = "/data/counts_individual/"
    >>> Ncells = 300000
    >>> Ngenes = 36601
    >>> aggregate_fastqs(path_to_outputs, meta_path_individual, counts_path_individual, Ncells, Ngenes)
    # Aggregates data from individual samples and saves the aggregated dataset.
    """
    print('preparing...')
    # initiate empty counts matrix and load as memmap
    counts_path = path_to_outputs + 'counts.npy'
    np.save(counts_path, np.empty(shape=(Ncells, Ngenes), dtype='int32'))
    cell_counts = np.lib.format.open_memmap(counts_path, mode='r+', dtype='int32', shape=(Ncells, Ngenes))

    # load metadata and get sample IDs
    ind_meta = pd.read_csv(meta_path_individual)
    n_metavars = ind_meta.shape[1]
    meta_path = path_to_outputs + 'metadata.npy'
    cell_meta = np.empty(shape=(Ncells, n_metavars), dtype=object)
    
    # initiate barcodes and features
    sample_ids = ind_meta['sample_id']
    n_ind = len(sample_ids)
    features_id_path = path_to_outputs + 'features_id.npy'
    np.save(features_id_path, np.empty(shape=Ngenes*n_ind, dtype='<U18'))
    features_id_out = np.lib.format.open_memmap(features_id_path, mode='r+', dtype='<U18')

    features_name_path = path_to_outputs + 'features_name.npy'
    np.save(features_name_path, np.empty(shape=Ngenes*n_ind, dtype='<U18'))
    features_name_out = np.lib.format.open_memmap(features_name_path, mode='r+', dtype='<U18')

    barcodes_path = path_to_outputs + 'barcodes.npy'
    np.save(barcodes_path, np.empty(shape=Ncells, dtype='<U18'))
    barcodes_out = np.lib.format.open_memmap(barcodes_path, mode='r+', dtype='<U18')
 
    # combine matrices
    counter = 0    
    counter = combine_matrices(sample_ids, cell_meta, ind_meta, cell_counts, counts_path_individual, features_id_out, features_name_out, barcodes_out, counter, Ngenes)
    
    # truncate arrays
    truncate_array(barcodes_path, barcodes_out, counter, Ncells, Ngenes)
    truncate_array(counts_path, cell_counts, counter, Ncells, Ngenes)

    # save metadata
    print('saving metadata')
    np.save(meta_path, cell_meta[:counter])
    print('done.')
    
def combine_matrices(sample_ids, cell_meta, ind_meta, cell_counts, counts_path_individual, features_id_out, features_name_out, barcodes_out, counter, Ngenes):
    """
    Combine gene expression matrices and associated metadata for multiple samples.

    Args:
        sample_ids (list): List of sample identifiers to be combined.
        cell_meta (numpy.ndarray): Memory-mapped array to store cell metadata.
        ind_meta (pandas.DataFrame): DataFrame containing individual sample metadata.
        cell_counts (numpy.ndarray): Memory-mapped array to store cell counts.
        counts_path_individual (str): Path to the directory containing individual sample data.
        features_id_out (numpy.ndarray): Memory-mapped array to store feature (gene) IDs.
        features_name_out (numpy.ndarray): Memory-mapped array to store feature (gene) names.
        barcodes_out (numpy.ndarray): Memory-mapped array to store cell barcodes.
        counter (int): Current position in the memory-mapped arrays.
        Ngenes (int): Number of genes in each matrix.

    Returns:
        int: Updated value of the counter.

    Notes:
    ------
    This function combines gene expression matrices and associated metadata for multiple samples.
    It iterates through the specified sample IDs, aggregates data, and updates memory-mapped arrays.

    Example:
    --------
    >>> sample_ids = ['SampleA', 'SampleB', 'SampleC']
    >>> cell_meta = np.memmap("cell_metadata.npy", dtype='int32', mode='w+', shape=(10000,))
    >>> ind_meta = pd.DataFrame({'sample_id': sample_ids, 'metadata_column': [1, 2, 3]})
    >>> cell_counts = np.memmap("cell_counts.npy", dtype='int32', mode='w+', shape=(10000,))
    >>> counts_path_individual = "/data/samples/"
    >>> features_id_out = np.memmap("feature_ids.npy", dtype='U', mode='w+', shape=(30000,))
    >>> features_name_out = np.memmap("feature_names.npy", dtype='U', mode='w+', shape=(30000,))
    >>> barcodes_out = np.memmap("barcodes.npy", dtype='U', mode='w+', shape=(10000,))
    >>> counter = 0
    >>> Ngenes = 3000
    >>> counter = combine_matrices(sample_ids, cell_meta, ind_meta, cell_counts, counts_path_individual, features_id_out, features_name_out, barcodes_out, counter, Ngenes)
    # Combines gene expression matrices and metadata for multiple samples.
    """
    for i in (range(len(sample_ids))):
        ID = sample_ids[i]
        print('aggregating ' + str(ID))
        subset_meta = np.array(ind_meta[ind_meta['sample_id']==ID])[0]
        counter = write_matrix(ID, counts_path_individual, cell_counts, cell_meta, subset_meta, counter, features_id_out, features_name_out, barcodes_out, Ngenes, i)
    return counter

